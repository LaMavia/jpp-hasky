-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transLIdent :: Abs.LIdent -> Result
transLIdent x = case x of
  Abs.LIdent string -> failure x

transUIdent :: Abs.UIdent -> Result
transUIdent x = case x of
  Abs.UIdent string -> failure x

transProgram :: Show a => Abs.Program' a -> Result
transProgram x = case x of
  Abs.Program _ topdefs -> failure x

transTopDef :: Show a => Abs.TopDef' a -> Result
transTopDef x = case x of
  Abs.TDDataV _ uident lidents constructors -> failure x
  Abs.TDDataNV _ uident constructors -> failure x
  Abs.TDDeclaration _ lident type_ expr -> failure x
  Abs.TDDeclarationNT _ lident expr -> failure x

transType :: Show a => Abs.Type' a -> Result
transType x = case x of
  Abs.TVar _ lident -> failure x
  Abs.TApp _ uident1 uident2 types -> failure x
  Abs.TType _ uident -> failure x
  Abs.TBound _ lidents type_ -> failure x

transConstructor :: Show a => Abs.Constructor' a -> Result
transConstructor x = case x of
  Abs.Constructor _ uident types -> failure x
  Abs.NullaryConstr _ uident -> failure x

transArg :: Show a => Abs.Arg' a -> Result
transArg x = case x of
  Abs.Arg _ lident type_ -> failure x

transExpr :: Show a => Abs.Expr' a -> Result
transExpr x = case x of
  Abs.ELet _ expr1 type_ expr2 expr3 -> failure x
  Abs.ELetNT _ expr1 expr2 expr3 -> failure x
  Abs.EMatch _ expr matchbranchs -> failure x
  Abs.EIf _ expr1 expr2 expr3 -> failure x
  Abs.ELambda _ args expr -> failure x
  Abs.EList _ exprs -> failure x
  Abs.EId _ lident -> failure x
  Abs.EConstr _ uident1 uident2 -> failure x
  Abs.EIgnore _ -> failure x
  Abs.EApp _ expr exprs -> failure x
  Abs.ELit _ literal -> failure x
  Abs.Neg _ expr -> failure x
  Abs.Not _ expr -> failure x
  Abs.EMul _ expr1 mulop expr2 -> failure x
  Abs.EAdd _ expr1 addop expr2 -> failure x
  Abs.ERel _ expr1 relop expr2 -> failure x
  Abs.EAnd _ expr1 expr2 -> failure x
  Abs.EOr _ expr1 expr2 -> failure x

transMatchBranch :: Show a => Abs.MatchBranch' a -> Result
transMatchBranch x = case x of
  Abs.MBBranch _ expr1 expr2 -> failure x

transLiteral :: Show a => Abs.Literal' a -> Result
transLiteral x = case x of
  Abs.LInt _ integer -> failure x

transAddOp :: Show a => Abs.AddOp' a -> Result
transAddOp x = case x of
  Abs.Plus _ -> failure x
  Abs.Minus _ -> failure x

transMulOp :: Show a => Abs.MulOp' a -> Result
transMulOp x = case x of
  Abs.Times _ -> failure x
  Abs.Div _ -> failure x
  Abs.Mod _ -> failure x

transRelOp :: Show a => Abs.RelOp' a -> Result
transRelOp x = case x of
  Abs.LTH _ -> failure x
  Abs.LE _ -> failure x
  Abs.GTH _ -> failure x
  Abs.GE _ -> failure x
  Abs.EQU _ -> failure x
  Abs.NE _ -> failure x
