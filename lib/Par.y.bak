-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Abs
import Lex

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)     }
  '!='     { PT _ (TS _ 2)     }
  '%'      { PT _ (TS _ 3)     }
  '&&'     { PT _ (TS _ 4)     }
  '('      { PT _ (TS _ 5)     }
  ')'      { PT _ (TS _ 6)     }
  '*'      { PT _ (TS _ 7)     }
  '+'      { PT _ (TS _ 8)     }
  ','      { PT _ (TS _ 9)     }
  '-'      { PT _ (TS _ 10)    }
  '->'     { PT _ (TS _ 11)    }
  '.'      { PT _ (TS _ 12)    }
  '/'      { PT _ (TS _ 13)    }
  '::'     { PT _ (TS _ 14)    }
  ';;'     { PT _ (TS _ 15)    }
  '<'      { PT _ (TS _ 16)    }
  '<='     { PT _ (TS _ 17)    }
  '='      { PT _ (TS _ 18)    }
  '=='     { PT _ (TS _ 19)    }
  '=>'     { PT _ (TS _ 20)    }
  '>'      { PT _ (TS _ 21)    }
  '>='     { PT _ (TS _ 22)    }
  '['      { PT _ (TS _ 23)    }
  ']'      { PT _ (TS _ 24)    }
  '_'      { PT _ (TS _ 25)    }
  'else'   { PT _ (TS _ 26)    }
  'fun'    { PT _ (TS _ 27)    }
  'if'     { PT _ (TS _ 28)    }
  'in'     { PT _ (TS _ 29)    }
  'let'    { PT _ (TS _ 30)    }
  'match'  { PT _ (TS _ 31)    }
  'then'   { PT _ (TS _ 32)    }
  'type'   { PT _ (TS _ 33)    }
  'with'   { PT _ (TS _ 34)    }
  '|'      { PT _ (TS _ 35)    }
  '||'     { PT _ (TS _ 36)    }
  L_integ  { PT _ (TI _)       }
  L_LIdent { PT _ (T_LIdent _) }
  L_UIdent { PT _ (T_UIdent _) }

%%

Integer :: { (Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

LIdent :: { (Abs.BNFC'Position, Abs.LIdent) }
LIdent  : L_LIdent { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LIdent (tokenText $1)) }

UIdent :: { (Abs.BNFC'Position, Abs.UIdent) }
UIdent  : L_UIdent { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.UIdent (tokenText $1)) }

Program :: { (Abs.BNFC'Position, Abs.Program) }
Program : ListTopDef { (fst $1, Abs.Program (fst $1) (snd $1)) }

ListTopDef :: { (Abs.BNFC'Position, [Abs.TopDef]) }
ListTopDef
  : TopDef ';;' { (fst $1, (:[]) (snd $1)) }
  | TopDef ';;' ListTopDef { (fst $1, (:) (snd $1) (snd $3)) }

TopDef :: { (Abs.BNFC'Position, Abs.TopDef) }
TopDef
  : 'type' UIdent '(' ListLIdent ')' '=' ListConstructor { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TDDataV (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $7)) }
  | 'type' UIdent '=' ListConstructor { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TDDataNV (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | LIdent '::' Type '=' Expr { (fst $1, Abs.TDDeclaration (fst $1) (snd $1) (snd $3) (snd $5)) }
  | LIdent '=' Expr { (fst $1, Abs.TDDeclarationNT (fst $1) (snd $1) (snd $3)) }

ListConstructor :: { (Abs.BNFC'Position, [Abs.Constructor]) }
ListConstructor
  : Constructor { (fst $1, (:[]) (snd $1)) }
  | Constructor '|' ListConstructor { (fst $1, (:) (snd $1) (snd $3)) }

ListLIdent :: { (Abs.BNFC'Position, [Abs.LIdent]) }
ListLIdent
  : LIdent { (fst $1, (:[]) (snd $1)) }
  | LIdent ',' ListLIdent { (fst $1, (:) (snd $1) (snd $3)) }

Type :: { (Abs.BNFC'Position, Abs.Type) }
Type
  : LIdent { (fst $1, Abs.TVar (fst $1) (snd $1)) }
  | UIdent '(' ListType ')' { (fst $1, Abs.TApp (fst $1) (snd $1) (snd $3)) }
  | UIdent { (fst $1, Abs.TType (fst $1) (snd $1)) }
  | '(' ListLIdent ')' '=>' Type { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TBound (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }

ListType :: { (Abs.BNFC'Position, [Abs.Type]) }
ListType
  : Type { (fst $1, (:[]) (snd $1)) }
  | Type ',' ListType { (fst $1, (:) (snd $1) (snd $3)) }

Constructor :: { (Abs.BNFC'Position, Abs.Constructor) }
Constructor
  : UIdent '(' ListType ')' { (fst $1, Abs.Constructor (fst $1) (snd $1) (snd $3)) }
  | UIdent { (fst $1, Abs.NullaryConstr (fst $1) (snd $1)) }

Arg :: { (Abs.BNFC'Position, Abs.Arg) }
Arg : LIdent Type { (fst $1, Abs.Arg (fst $1) (snd $1) (snd $2)) }

Expr :: { (Abs.BNFC'Position, Abs.Expr) }
Expr
  : 'let' Expr '::' Type '=' Expr 'in' Expr { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.ELet (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6) (snd $8)) }
  | 'let' Expr '=' Expr 'in' Expr { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.ELetNT (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | 'match' Expr 'with' '(' ListMatchBranch ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.EMatch (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
  | 'if' Expr 'then' Expr 'else' Expr { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.EIf (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | 'fun' '(' ListArg ')' '->' Expr { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.ELambda (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $6)) }
  | '[' ListExpr ']' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.EList (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr1 '||' Expr { (fst $1, Abs.EOr (fst $1) (snd $1) (snd $3)) }
  | Expr1 { (fst $1, (snd $1)) }

Expr6 :: { (Abs.BNFC'Position, Abs.Expr) }
Expr6
  : LIdent { (fst $1, Abs.EId (fst $1) (snd $1)) }
  | UIdent '.' UIdent { (fst $1, Abs.EConstr (fst $1) (snd $1) (snd $3)) }
  | '_' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.EIgnore (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | Expr6 '(' ListExpr ')' { (fst $1, Abs.EApp (fst $1) (snd $1) (snd $3)) }
  | Literal { (fst $1, Abs.ELit (fst $1) (snd $1)) }
  | '(' Expr ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Expr5 :: { (Abs.BNFC'Position, Abs.Expr) }
Expr5
  : '-' Expr6 { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Neg (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '!' Expr6 { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Not (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr6 { (fst $1, (snd $1)) }

Expr4 :: { (Abs.BNFC'Position, Abs.Expr) }
Expr4
  : Expr4 MulOp Expr5 { (fst $1, Abs.EMul (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr5 { (fst $1, (snd $1)) }

Expr3 :: { (Abs.BNFC'Position, Abs.Expr) }
Expr3
  : Expr3 AddOp Expr4 { (fst $1, Abs.EAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr4 { (fst $1, (snd $1)) }

Expr2 :: { (Abs.BNFC'Position, Abs.Expr) }
Expr2
  : Expr2 RelOp Expr3 { (fst $1, Abs.ERel (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr3 { (fst $1, (snd $1)) }

Expr1 :: { (Abs.BNFC'Position, Abs.Expr) }
Expr1
  : Expr2 '&&' Expr1 { (fst $1, Abs.EAnd (fst $1) (snd $1) (snd $3)) }
  | Expr2 { (fst $1, (snd $1)) }

ListExpr :: { (Abs.BNFC'Position, [Abs.Expr]) }
ListExpr
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | Expr { (fst $1, (:[]) (snd $1)) }
  | Expr ',' ListExpr { (fst $1, (:) (snd $1) (snd $3)) }

ListArg :: { (Abs.BNFC'Position, [Abs.Arg]) }
ListArg
  : Arg { (fst $1, (:[]) (snd $1)) }
  | Arg ',' ListArg { (fst $1, (:) (snd $1) (snd $3)) }

ListMatchBranch :: { (Abs.BNFC'Position, [Abs.MatchBranch]) }
ListMatchBranch
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | MatchBranch ListMatchBranch { (fst $1, (:) (snd $1) (snd $2)) }

MatchBranch :: { (Abs.BNFC'Position, Abs.MatchBranch) }
MatchBranch
  : '|' Expr '->' Expr { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.MBBranch (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

Literal :: { (Abs.BNFC'Position, Abs.Literal) }
Literal : Integer { (fst $1, Abs.LInt (fst $1) (snd $1)) }

AddOp :: { (Abs.BNFC'Position, Abs.AddOp) }
AddOp
  : '+' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Plus (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Minus (uncurry Abs.BNFC'Position (tokenLineCol $1))) }

MulOp :: { (Abs.BNFC'Position, Abs.MulOp) }
MulOp
  : '*' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Times (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Div (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '%' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Mod (uncurry Abs.BNFC'Position (tokenLineCol $1))) }

RelOp :: { (Abs.BNFC'Position, Abs.RelOp) }
RelOp
  : '<' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LTH (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LE (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.GTH (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.GE (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '==' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.EQU (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.NE (uncurry Abs.BNFC'Position (tokenLineCol $1))) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Abs.Program
pProgram = fmap snd . pProgram_internal
}

